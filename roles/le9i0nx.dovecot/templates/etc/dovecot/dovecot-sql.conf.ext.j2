## This file is managed by Ansible, all changes will be lost
# Этот файл открывается с правами пользователя root, поэтому
# он должен принадлежать пользователю root и иметь права
# доступа 0600.
#
# http://wiki2.dovecot.org/AuthDatabase/SQL
#
# Для модуля sql passdb вам нужна база данных с таблицей, содержащая
# как минимум поля "имя пользователя" и "пароль". Если вы хотите
# использовать синтакс user@domain, то вам понадобится отдельное
# поле для имени домена.
#
# Если все ваши пользователи имеют одинаковые uid/gid и одинаковую
# общую часть вначале пути (наример, /var/mail, /usr/home), то вы можете
# использовать модуль static userdb для генерации остального пути к
# домашней директории из имени пользователя и домена. В этом случае
# вам не понадобятся поля home, uid, gid в таблице в базе данных.
#
# Если у вас есть необходимость использовать модуль sql userdb, то
# вам придется создать поля home, uid, и gid. Вот пример таблицы:
#
# CREATE TABLE users (
#     username VARCHAR(128) NOT NULL,
#     domain VARCHAR(128) NOT NULL,
#     password VARCHAR(64) NOT NULL,
#     home VARCHAR(255) NOT NULL,
#     uid INTEGER NOT NULL,
#     gid INTEGER NOT NULL,
#     active CHAR(1) DEFAULT 'Y' NOT NULL
# );
 
# Используемая база данных: mysql, pgsql, sqlite
driver = {{dovecot_db_type}}
 
# Подключение к базе данных. Специфичные настройки для драйвера.
#
# HA / round-robin load-balancing is supported by giving multiple host
# settings, like: host=sql1.host.org host=sql2.host.org
#
# pgsql:
#   Смотрите в документацию PostgreSQL по функции PQconnectdb
#   допустимые параметры. Используйте maxconns=n (по умолчанию 5)
#   для ограничения количества подключений Dovecot к базе данных. 
#
# mysql:
#   Имена основных параметров аналогичны PostgreSQL:
#     host, port, user, password, dbname
#
#   Также доступны следующие параметры:
#     client_flags        - смотрите документацию по MySQL
#     ssl_ca, ssl_ca_path - задайте одну или две опции, чтобы включить SSL
#     ssl_cert, ssl_key   - для отправки сертификата клиента на сервер
#     ssl_cipher          - минимальная безопасность шифра (по умолчанию: HIGH)
#     option_file         - читать параметры из файла (указанного здесь) для клиента
#                            MySQL, вместо файла по умолчанию - my.cnf.
#     option_group        - читать параметры из определенной группы (по умолчанию: client)
# 
#   Вы можете указать в параметре host путь к Unix сокету: host=/var/run/mysql.sock
#   Учтите, что на данный момент нельзя использовать пробелы в параметрах.
#   
# sqlite:
#   Путь к файлу базы данных.
#
# Примеры:
#   connect = host=192.168.1.1 dbname=users
#   connect = host=sql.example.com dbname=virtual user=virtual password=blarg
#   connect = /etc/dovecot/authdb.sqlite
#
connect = host=/run/mysqld/mysqld.sock dbname={{dovecot_db_name}} user={{dovecot_db_user}} password={{dovecot_db_password}}
 
# Формат хранения паролей по умолчанию.
#
# Список поддерживаемых схем смотрите здесь:
# http://wiki2.dovecot.org/Authentication/PasswordSchemes
#
default_pass_scheme = CRAM-MD5
 
# Запрос passdb, который возвращает пароль. Он может вернуть следующие поля:
#   password - пароль пользователя. Это поле всегда должно присутствовать.
#   user - возвращается в формате user@domain.
#   username и domain - другой путь представления поля "user".
#
# Поле "user" должно быть регистронезависимым, чтобы избежать
# создания двух директорий (почтовых ящиков), если вдруг пользователь
# предоставит учетные данные по разному: "name" и "nAme". Если имя пользователя
# и имя домена хрантся в разных колонках, то вы можете вернуть колонки
# "username" и "domain" вместо одной "user".
#
# Также запрос может вернуть другие поля, которые имеют свое назначение,
# смотрите список таких полей здесь:
# http://wiki2.dovecot.org/PasswordDatabase/ExtraFields
#
# Подстановки, используемые чаще всего: (смотрите полный список подстановок
# здесь - http://wiki2.dovecot.org/Variables):
#   %u = entire user@domain
#   %n = user part of user@domain
#   %d = domain part of user@domain
#
# Учтите, что подстановки могут использоваться только в SQL запросе. Если
# запрос возвращает любую из этих подстановок, то ничего не изменяется.
# Иначе было бы невозможно задавать имя пользователя, в котором
# присутствовал бы символ '%'.
#
# Пример:
#   password_query = SELECT userid AS user, pw AS password \
#     FROM users WHERE userid = '%u' AND active = 'Y'
#
#password_query = SELECT `username` as `user`, `password` FROM  `mailbox` WHERE `username` = '%u' AND `active`='1'
password_query = \
	SELECT  mailbox.username as user, mailbox.password, mailbox.domain as domain \
	FROM  mailbox \
	JOIN domain ON mailbox.domain = domain.domain \
	WHERE username = '%u' AND \
		mailbox.active='1' AND \
		domain.active='1'

#password_query = \
#	SELECT	"mailbox"."username" AS "username", \
#			"domain"."domain" AS "domain", \
#			"mailbox"."password" AS "password" \
##			CONCAT('/var/mail/',"mailbox"."maildir") AS "userdb_home", \
##			"home AS userdb_home, uid AS userdb_uid, gid AS userdb_gid \
#	FROM	"mailbox" \
#		INNER JOIN "domain" ON ("mailbox"."domain" = "domain"."domain") \
#		WHERE	"mailbox"."username" = '%u' AND \
##				"domain"."domain" = '%d' AND \
#				"mailbox"."active" = '1' AND \
#				"domain"."active" = '1'

#password_query = \
#	SELECT	"users_tb"."username" AS "username", \
#			"domains_tb"."domainname" AS "domain", \
#			"users_tb"."passwd" AS "password" \
#	FROM "users_tb" \
#		INNER JOIN "domains_tb" ON ("users_tb"."domain_id" = "domains_tb"."id") \
#		WHERE "users_tb"."username" = '%n' AND \
#			"domains_tb"."domainname" = '%d' AND \
#			"users_tb"."active" = 'true' AND \
#			"domains_tb"."active" = 'true'


# Запрос, который возвращает информацию о пользователе. Он может вернуть:
#   uid - System UID (overrides mail_uid setting)
#   gid - System GID (overrides mail_gid setting)
#   home - Home directory
#   mail - Mail location (overrides mail_location setting)
#
# Ни одно из этих полей не является обязательным. Если вы используете
# везде одинаковые UID и GID, и различными у вас остаются только
# home или mail, то вам лучше использовать userdb static.
# Полный список возможных полей смотрите здесь:
# http://wiki2.dovecot.org/UserDatabase/ExtraFields
#
# Примеры:
#   user_query = SELECT home, uid, gid FROM users WHERE userid = '%u'
#   user_query = SELECT dir AS home, user AS uid, group AS gid FROM users where userid = '%u'
#   user_query = SELECT home, 501 AS uid, 501 AS gid FROM users WHERE userid = '%u'
#
#user_query = SELECT '/home/vmail/%d/%n' as home, 3000 AS uid, 3000 AS gid FROM mailbox WHERE username = '%u'

#user_query = \
#	SELECT	CONCAT('/var/mail/',"mailbox"."maildir") AS "home" \
##			'dovecot' AS `uid`, \
##			'dovecot' AS `gid` \
#	FROM	"mailbox" \
#		INNER JOIN "domain" ON ("mailbox"."domain" = "domain"."domain") \
#		WHERE	"mailbox"."username" = '%u' AND \
##				"domain"."domain" = '%d' AND \
#				"mailbox"."active" = '1' AND \
#				"domain"."active" = '1'

#user_query = \
#	SELECT "users_tb"."uid" AS "uid", "users_tb"."gid" AS "gid", \
#		("users_tb"."homedir" || '/%d/%n') AS "home", \
#		('*:storage=' || "users_tb"."quota" || 'k') AS "quota_rule" \
#	FROM "users_tb" \
#	INNER JOIN "domains_tb" ON ("users_tb"."domain_id" = "domains_tb"."id") \
#		WHERE "users_tb"."username" = '%n' AND \
#			"domains_tb"."domainname" = '%d' AND \
#			"users_tb"."active" = 'true' AND \
#			"domains_tb"."active" = 'true'


# Если вы не хотите использовать два запроса (passdb + userdb), то вы можете
# использовать userdb prefetch вместо userdb sql. В этом случае вы должны
# сделать так, чтобы запрос в password_query возвращал поля userdb
# с префиксом "userdb_". Например:
#password_query = \
#  SELECT userid AS user, password, \
#    home AS userdb_home, uid AS userdb_uid, gid AS userdb_gid \
#  FROM users WHERE userid = '%u'

# Запрос для получения списка всех пользователей.
#iterate_query = SELECT username AS user FROM users
